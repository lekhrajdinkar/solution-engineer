## PODS : intro
- containers are encapsulated inside pods
- HPA (horizontal pod scaling) 
    - **declarative**: kubectl autoscale deployment  deployment-1 --max=10 --cpu-percent=70
    - also define yaml spec.
- VPA (vertical pod scaling)
- can have **multi-container pod** (rare use-case)
    - c1 - api
    - c2 - some helper api
    - both live/die together
    - shares same name network and storage by-default.
-  `subdomain` and `hostname`  👈🏻
- If two Pods use the same PVC, they will share the **same underlying storage**
- use **volumeClaimTemplates**

## pod : description yaml
```yaml
apiVersion:
kind:
metadata:
  name: pod-1
  label:
    - key1: value1
    - key1: value1
  
  ## pod level
  securityContext🔷:
    runAsUser: 1000
annotation:
  secret.reloader.stakater.com/auto: "true" 
  configmap.reloader.stakater.com/auto: "true" 
  reloader.stakater.com/auto: "true" 
  
spec:
  🟡tolerations:
  
  🟡nodeSelector:
      kubernetes.io/arch: "amd64" # "arm64"
      karpenter.sh/capacity-type: "spot"    ❓     
    
  🟡affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      preferredDuringSchedulingIgnoredDuringExecution:
      requiredDuringSchedulingRequiredDuringExecution: future

      volumes ✅:
          - name: app-logs
            emptyDir🔸: {}
          - name: config
            configMap🔸:
              name: fluent-bit-config
          - name: docker-socket
            hostPath🔸:
              path: /var/run/docker.sock
  
  🔸restartPolicy: Always | Never 
  🔸serviceAccountName: sa-1 #default  is default sa
  🔸resources:  # better to use LimitRange object
      request:
      limit:
      
  initContainers:
    -
    -
  containers:
    - name: c1
      image: 
      command 🔸: # ["sleep"]  #ENTRYPOINT of dockerfile or --entrypoint of dcoker run ...
        - sleep
      args 🔸: #["10"] CMD of dockerfile or docker run --entrypoint <> ...
        - 10
      ports:
        - containerPort: 8080
        - containerPort: 8443
      env:
        - name:
          value :
        - name:
          valueFrom: 
            🔸configMapKeyRef :
              - name:
                key: 
        - name:
          valueFrom: 
            🔸secretKeyRef: 
              - name:
                key: 
                  
      volumeMounts 🔸:
        - name: app-logs
          mountPath: /var/log/app
          
      logging 🔸🔸:
          driver: awslogs
          options:
            awslogs-group: "/eks/fargate-logs"
            awslogs-region: "us-east-1"
            awslogs-stream-prefix: "my-app"  
            
      securityContext🔷:    ## contaioner level
          runAsUser: 1000
          capabilities: 
            add: ["MAC_ADMIN", "SYS_TIME", "NET_ADMIN"]
            drop: ["ALL"]
          allowPrivilegeEscalation: false
          runAsGroup: 101      
           
    - name: c2
      image:
```

## pod : commands
```
- kubectl get/describe pod pod-1
- kubectl get pod <pod-name> -o yaml > pod-definition.yaml
- kubectl edit pod <pod-name>
  
== Edit ==  
  - only the properties listed below are editable: ✅
      spec.containers[*].image
      spec.initContainers[*].image
      spec.activeDeadlineSeconds
      spec.tolerations
      spec.terminationGracePeriodSeconds

  - cannot edit ❌
      env var
      sa
      resource limits 
 
      delete and re-create ✅
        - kubectl get pod pod-1 -o yaml > my-new-pod.yaml > edit it
        - kubectl delete pod pod-1    
        - kubectl create -f  my-new-pod-new.yaml
```

--- 
## initContainers
- task that will be **run only one time** when the pod is first created. 
- eg: DB Script, read from storage, etc
- once completed,  the **real container** hosting the application starts.
- configure **multiple** such initContainer.
    - run one at a time in sequential order
- If any of the initContainers fail to complete, Kubernetes restarts the Pod repeatedly until the Init Container succeeds.
- [more](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/)

---
## Design pattern for multiple-container pod
- if any container fails, pod failed.
- All containers  in pod are expected to stay alive at all times.
### A. Sidecar
- One main container performs the primary task,
- and additional containers (sidecars) provide **supporting functionality**, 
- like `logging, proxying, or data syncing`.

### B. Adaptor
- An adapter container **transforms** data or interfaces between different systems or services, making them compatible with the main application.

### C. Ambassador
- A container (ambassador) acts as a **proxy** for external services,
- managing network requests and responses for the main container.
